---
comment: false
aside:
  toc: true

title: 缓存穿透、缓存击穿及缓存雪崩
date: 2021-03-14 14:35
tags: 缓存
---

## 缓存穿透

指缓存和数据库中都没有的数据，而用户不断发起请求。

> 这时的用户很可能是攻击者，攻击会导致数据库压力过大。

### 解决方案

#### 缓存空对象

无论是否从数据库查询到数据，均设置缓存。未查询到的数据，设置为`Null`。

**缺点:**

1. 只能防止同一个不存在的数据多次查询;

    > 比如: 会员`M001`不存在, 此方式只能有效解决`M001`多次查询, 而无法避免每次查询的都是不存在的数据。 

2. 导致缓存大量空数据;

3. 导致内存紧张;

#### 布隆(bloom)过滤器 `推荐`{:.success}

##### 位图(bitmap)

布隆过滤器其中重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有1个bit，而每个bit只有`0`和`1`两种状态。bitarray也叫bitmap，大小也就是布隆过滤器的大小。

<font color='#FF6A6A'>假设一种有k个哈希函数，且每个哈希函数的输出范围都大于m，接着将输出值对k取余(%m)，就会得到k个[0, m-1]的值。</font>由于每个哈希函数之间相互独立，因此这k个数也相互独立，最后将这k个数对应到bitarray上并标记为`1`。

等判断时，将输入对象经过这k个哈希函数计算得到k个值，然后判断对应bitarray的k个位置是否都为`1`，如果有一个不为黑，那么这个输入对象则不在这个集合中，也就不是黑名单了！如果都是黑，那说明在集合中，但有可能会误，由于当输入对象过多，而集合也就是bitarray过小，则会出现大部分为黑的情况，那样就容易发生误判！因此使用布隆过滤器是需要容忍错误率的。

1. 定义`位数组`, 初始每个位置都为`0`;
2. 定义`Hash函数`。计算的哈希结果，长度在`0`至`位数组`长度-1之间;
3. 计通过`Hash函数`计算值结果, 对应的二进制码`数组下标`位置内容替换为1。表示此值存在;

**缺点**

1. 因为会发生Hash碰撞, 判断数据是否存在集合中时, 会把不存在的数据判断存在(不存在的数据一定不会存在)。有一定概率存在误判;

    * 增加数组的长度, 提高Hash散列, 降低碰撞;
    * 增加参与计算的Hash函数, 多个结果标记一个值;

2. 无法删除;

## 缓存击穿

指缓存中没有, 但数据库存在数据(一般是缓存时间到期)。 

> 如果并发用户特别多, 同时未读取到该缓存数据。引起数据库压力瞬间增大。

### 解决方案

1. 可以加锁只保持一个线程去读取数据并设置缓存, 之后请求可以直接读取缓存;

## 缓存雪崩

缓存中大量的热门数据, 某刻突然失效。而查询数据量巨大, 引起数据库压力剧增导致宕机。

### 解决方案

1. 设置不同的到期时间;
2. 将缓存数据分片, 分担数据库访问压力;
3. 设置热点数据监控延期机制;